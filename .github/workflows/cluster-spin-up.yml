name: Cluster Spin Up

on:
  workflow_dispatch:  # Manual trigger from GitHub UI
  # Optional: Uncomment to schedule automatic spin-up
  # schedule:
  #   - cron: '0 8 * * 1-5'  # 8 AM weekdays (Mon-Fri)

permissions:
  id-token: write
  contents: read

jobs:
  spin-up:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/cs3219-eks-gha-deployer
          aws-region: ${{ secrets.AWS_REGION || 'ap-southeast-1' }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Init
        working-directory: infra/terraform/eks
        run: terraform init

      - name: Terraform Apply
        working-directory: infra/terraform/eks
        run: terraform apply -auto-approve

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name cs3219-eks --region ${{ secrets.AWS_REGION || 'ap-southeast-1' }}

      - name: Deploy Kubernetes Resources
        run: |
          # Create namespace
          kubectl apply -f infra/k8s/namespace.yaml
          
          # Create secrets from Parameter Store
          kubectl create secret generic db-secrets -n cs3219 \
            --from-literal=question-db-user=questionuser \
            --from-literal=question-db-password=$(aws ssm get-parameter --name /cs3219/db/question-password --with-decryption --query 'Parameter.Value' --output text) \
            --from-literal=question-db-name=questiondb \
            --from-literal=user-db-user=user \
            --from-literal=user-db-password=$(aws ssm get-parameter --name /cs3219/db/user-password --with-decryption --query 'Parameter.Value' --output text) \
            --from-literal=user-db-name=userdb \
            --from-literal=redis-password="" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          kubectl create secret generic app-secrets -n cs3219 \
            --from-literal=jwt-secret=$(aws ssm get-parameter --name /cs3219/jwt-secret --with-decryption --query 'Parameter.Value' --output text) \
            --from-literal=google-client-id=$(aws ssm get-parameter --name /cs3219/google-client-id --query 'Parameter.Value' --output text) \
            --from-literal=google-client-secret=$(aws ssm get-parameter --name /cs3219/google-client-secret --with-decryption --query 'Parameter.Value' --output text) \
            --from-literal=google-callback-url=https://your-domain.com/auth/google/callback \
            --dry-run=client -o yaml | kubectl apply -f -
          
          # Deploy config and policies
          kubectl apply -f infra/k8s/configmap.yaml
          kubectl apply -f infra/k8s/resource-quota.yaml
          kubectl apply -f infra/k8s/network-policy.yaml
          
          # Deploy databases
          kubectl apply -f infra/k8s/postgres-question.yaml
          kubectl apply -f infra/k8s/postgres-user.yaml
          kubectl apply -f infra/k8s/redis.yaml
          
          # Wait for databases
          echo "â³ Waiting for databases to be ready..."
          kubectl wait --for=condition=ready pod -l app=question-db -n cs3219 --timeout=300s || true
          kubectl wait --for=condition=ready pod -l app=user-db -n cs3219 --timeout=300s || true
          kubectl wait --for=condition=ready pod -l app=matching-redis -n cs3219 --timeout=300s || true

      - name: Restore Database Backups (if exist)
        continue-on-error: true
        run: |
          # Check if S3 bucket exists
          if aws s3 ls s3://cs3219-db-backups-${{ secrets.AWS_ACCOUNT_ID }} 2>/dev/null; then
            echo "ðŸ“¥ Restoring database backups..."
            
            # Restore Question DB
            aws s3 cp s3://cs3219-db-backups-${{ secrets.AWS_ACCOUNT_ID }}/question-db-latest.sql.gz /tmp/ || echo "No question DB backup found"
            if [ -f /tmp/question-db-latest.sql.gz ]; then
              gunzip /tmp/question-db-latest.sql.gz
              kubectl exec -i -n cs3219 deployment/question-db -- psql -U questionuser questiondb < /tmp/question-db-latest.sql
            fi
            
            # Restore User DB
            aws s3 cp s3://cs3219-db-backups-${{ secrets.AWS_ACCOUNT_ID }}/user-db-latest.sql.gz /tmp/ || echo "No user DB backup found"
            if [ -f /tmp/user-db-latest.sql.gz ]; then
              gunzip /tmp/user-db-latest.sql.gz
              kubectl exec -i -n cs3219 deployment/user-db -- psql -U user userdb < /tmp/user-db-latest.sql
            fi
            
            echo "âœ… Database restore complete"
          else
            echo "â„¹ï¸ No backup bucket found, skipping restore"
          fi

      - name: Deploy Application Services
        run: |
          kubectl apply -f infra/k8s/question-service.yaml
          kubectl apply -f infra/k8s/user-service.yaml
          kubectl apply -f infra/k8s/matching-service.yaml
          kubectl apply -f infra/k8s/api.yaml
          kubectl apply -f infra/k8s/web.yaml
          kubectl apply -f infra/k8s/hpa.yaml
          kubectl apply -f infra/k8s/ingress.yaml

      - name: Get Cluster Status
        run: |
          echo "âœ… Cluster is up and running!"
          echo ""
          echo "ðŸ“Š Pods:"
          kubectl get pods -n cs3219
          echo ""
          echo "ðŸŒ Services:"
          kubectl get svc -n cs3219
          echo ""
          echo "ðŸšª Ingress:"
          kubectl get ingress -n cs3219
          echo ""
          echo "ðŸ”— ALB URL:"
          kubectl get ingress cs3219-ingress -n cs3219 -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
          echo ""
