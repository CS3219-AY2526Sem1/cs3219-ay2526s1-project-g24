import { Redis } from "ioredis";
import { logger } from "../observability/logger.js";
import { metrics } from "../observability/metrics.js";
import type { StoredMatchRequest, Difficulty } from "../types.js";
import { RedisKeys } from "../types.js";

export let redis: Redis;

export function initRedis() {
  const config = {
    host: process.env.REDIS_HOST || "localhost",
    port: parseInt(process.env.REDIS_PORT || "6379", 10),
    password: process.env.REDIS_PASSWORD || undefined,
    maxRetriesPerRequest: 3,
    retryStrategy: (times: number) => {
      const delay = Math.min(times * 50, 2000);
      return delay;
    },
  };

  redis = new Redis(config);

  redis.on("connect", () => {
    logger.info({ host: config.host, port: config.port }, "Redis connected");
  });

  redis.on("error", (error: Error) => {
    logger.error({ error }, "Redis connection error");
    metrics.recordError("redis_error", "connection");
  });

  redis.on("close", () => {
    logger.warn("Redis connection closed");
  });

  return redis;
}

export function getRedis(): Redis {
  if (!redis) {
    throw new Error("Redis client not initialized. Call initRedis() first.");
  }
  return redis;
}

export async function closeRedis() {
  if (redis) {
    await redis.quit();
    logger.info("Redis connection closed");
  }
}

/**
 * Wrapper for Redis operations with latency tracking
 */
function trackLatency<T>(operation: string, fn: () => Promise<T>): Promise<T> {
  const start = Date.now();
  return fn()
    .then((result) => {
      const duration = (Date.now() - start) / 1000;
      metrics.recordRedisOperation(operation, duration);
      return result;
    })
    .catch((error) => {
      const duration = (Date.now() - start) / 1000;
      metrics.recordRedisOperation(operation, duration);
      metrics.recordError("redis_error", operation);
      throw error;
    });
}

/**
 * Redis operations for match requests
 */
export const redisOps = {
  /**
   * Create a match request in Redis
   */
  async createRequest(
    reqId: string,
    request: Omit<StoredMatchRequest, "status" | "createdAt">,
    ttlSeconds: number = 60,
  ): Promise<void> {
    const redis = getRedis();
    const key = RedisKeys.request(reqId);
    const createdAt = Date.now();

    const data: StoredMatchRequest = {
      ...request,
      status: "queued",
      createdAt,
    };

    await trackLatency("hset", () =>
      redis.hset(key, {
        userId: data.userId,
        difficulty: data.difficulty,
        topics: data.topics,
        languages: data.languages,
        status: data.status,
        createdAt: data.createdAt.toString(),
      }),
    );

    // Only set expiration if ttlSeconds > 0
    if (ttlSeconds > 0) {
      await trackLatency("expire", () => redis.expire(key, ttlSeconds));
    }
  },

  /**
   * Get a match request from Redis
   */
  async getRequest(reqId: string): Promise<StoredMatchRequest | null> {
    const redis = getRedis();
    const key = RedisKeys.request(reqId);

    const data = (await trackLatency("hgetall", () =>
      redis.hgetall(key),
    )) as Record<string, string>;

    if (!data || Object.keys(data).length === 0) {
      return null;
    }

    return {
      userId: data.userId,
      difficulty: data.difficulty as Difficulty,
      topics: data.topics,
      languages: data.languages,
      status: data.status as StoredMatchRequest["status"],
      createdAt: parseInt(data.createdAt, 10),
      sessionId: data.sessionId,
    };
  },

  async updateRequestStatus(
    reqId: string,
    status: StoredMatchRequest["status"],
    sessionId?: string,
  ): Promise<void> {
    const redis = getRedis();
    const key = RedisKeys.request(reqId);

    const updates: Record<string, string> = { status };
    if (sessionId) {
      updates.sessionId = sessionId;
    }

    await trackLatency("hset", () => redis.hset(key, updates));
  },

  /**
   * Atomically update request status only if current status matches expected status
   * Uses Redis WATCH for optimistic locking to prevent race conditions
   *
   * @returns true if update succeeded, false if status was changed by another operation
   */
  async atomicUpdateRequestStatus(
    reqId: string,
    expectedStatus: StoredMatchRequest["status"],
    newStatus: StoredMatchRequest["status"],
    sessionId?: string,
  ): Promise<boolean> {
    const redis = getRedis();
    const key = RedisKeys.request(reqId);

    const maxRetries = 3;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        // Watch the key for changes
        await redis.watch(key);

        // Get current status
        const currentStatus = await redis.hget(key, "status");

        // Check if status matches expected
        if (currentStatus !== expectedStatus) {
          await redis.unwatch();
          logger.debug(
            { reqId, expectedStatus, currentStatus, newStatus },
            "Status mismatch - request status changed",
          );
          return false;
        }

        // Atomically update status if key hasn't changed
        const updates: Record<string, string> = { status: newStatus };
        if (sessionId) {
          updates.sessionId = sessionId;
        }

        const result = await trackLatency("multi", () =>
          redis.multi().hset(key, updates).exec(),
        );

        // result is null if transaction was aborted (key was modified)
        if (result === null) {
          logger.debug(
            { reqId, attempt: attempt + 1 },
            "Transaction aborted - retrying",
          );
          continue;
        }

        logger.debug(
          { reqId, expectedStatus, newStatus },
          "Atomic status update succeeded",
        );
        return true;
      } catch (error) {
        await redis.unwatch();
        throw error;
      }
    }

    logger.warn(
      { reqId, expectedStatus, newStatus, maxRetries },
      "Atomic status update failed after max retries",
    );
    return false;
  },

  async enqueue(
    reqId: string,
    difficulty: Difficulty,
    score: number,
  ): Promise<void> {
    const redis = getRedis();
    const queueKey = RedisKeys.queue(difficulty);

    await trackLatency("zadd", () => redis.zadd(queueKey, score, reqId));
  },

  async dequeue(reqId: string, difficulty: Difficulty): Promise<void> {
    const redis = getRedis();
    const queueKey = RedisKeys.queue(difficulty);

    await trackLatency("zrem", () => redis.zrem(queueKey, reqId));
  },

  /**
   * Pop multiple requests from queue (FIFO)
   */
  async popFromQueue(
    difficulty: Difficulty,
    count: number,
  ): Promise<Array<{ reqId: string; score: number }>> {
    const redis = getRedis();
    const queueKey = RedisKeys.queue(difficulty);

    // ZPOPMIN returns [member1, score1, member2, score2, ...]
    const results = (await trackLatency("zpopmin", () =>
      redis.zpopmin(queueKey, count),
    )) as string[];

    // Extract reqId and score pairs
    const items: Array<{ reqId: string; score: number }> = [];
    for (let i = 0; i < results.length; i += 2) {
      items.push({
        reqId: results[i],
        score: parseFloat(results[i + 1]),
      });
    }

    return items;
  },

  async getQueueLength(difficulty: Difficulty): Promise<number> {
    const redis = getRedis();
    const queueKey = RedisKeys.queue(difficulty);

    return trackLatency("zcard", () => redis.zcard(queueKey));
  },

  /**
   * Publish event to request channel
   */
  async publishEvent(reqId: string, event: Record<string, any>): Promise<void> {
    const redis = getRedis();
    const channel = RedisKeys.events(reqId);

    await trackLatency("publish", () =>
      redis.publish(channel, JSON.stringify(event)),
    );
  },

  /**
   * Subscribe to request events
   */
  createSubscriber(): Redis {
    const config = {
      host: process.env.REDIS_HOST || "localhost",
      port: parseInt(process.env.REDIS_PORT || "6379", 10),
      password: process.env.REDIS_PASSWORD || undefined,
    };

    return new Redis(config);
  },

  async healthCheck(): Promise<boolean> {
    try {
      const redis = getRedis();
      const result = await redis.ping();
      return result === "PONG";
    } catch (error) {
      logger.error({ error }, "Redis health check failed");
      return false;
    }
  },

  /**
   * Add request to timeout tracking sorted set
   * Score is the deadline timestamp (when the request should timeout)
   */
  async addTimeout(
    reqId: string,
    difficulty: Difficulty,
    timeoutSeconds: number,
  ): Promise<void> {
    const redis = getRedis();
    const deadline = Date.now() + timeoutSeconds * 1000;
    const member = `${reqId}:${difficulty}`;

    await trackLatency("zadd", () =>
      redis.zadd("match:timeouts", deadline, member),
    );
  },

  /**
   * Remove request from timeout tracking (when matched or cancelled)
   */
  async removeTimeout(reqId: string, difficulty: Difficulty): Promise<void> {
    const redis = getRedis();
    const member = `${reqId}:${difficulty}`;

    await trackLatency("zrem", () => redis.zrem("match:timeouts", member));
  },

  /**
   * Get all expired timeouts from sorted set
   * Returns array of {reqId, difficulty} for requests past their deadline
   */
  async getExpiredTimeouts(): Promise<
    Array<{ reqId: string; difficulty: Difficulty }>
  > {
    const redis = getRedis();
    const now = Date.now();

    // Get all members with score <= now (expired)
    const results = (await trackLatency("zrangebyscore", () =>
      redis.zrangebyscore("match:timeouts", "-inf", now),
    )) as string[];

    return results.map((member) => {
      const [reqId, difficulty] = member.split(":");
      return { reqId, difficulty: difficulty as Difficulty };
    });
  },

  /**
   * Remove expired timeouts from sorted set (cleanup after processing)
   */
  async removeExpiredTimeouts(): Promise<number> {
    const redis = getRedis();
    const now = Date.now();

    // Remove all members with score <= now
    const count = await trackLatency("zremrangebyscore", () =>
      redis.zremrangebyscore("match:timeouts", "-inf", now),
    );

    return count;
  },

  /**
   * Get count of pending timeouts
   */
  async getTimeoutCount(): Promise<number> {
    const redis = getRedis();
    return trackLatency("zcard", () => redis.zcard("match:timeouts"));
  },

  /**
   * Atomically retrieve and remove all expired timeouts.
   * Returns array of request identifiers that need to be processed.
   */
  async popExpiredTimeouts(limit?: number): Promise<
    Array<{ reqId: string; difficulty: Difficulty }>
  > {
    const redis = getRedis();
    const key = "match:timeouts";
    const now = Date.now();

    const multi = redis.multi();

    if (limit && limit > 0) {
      multi.zrangebyscore(key, "-inf", now, "LIMIT", 0, limit);
    } else {
      multi.zrangebyscore(key, "-inf", now);
    }

    multi.zremrangebyscore(key, "-inf", now);

    const results = (await trackLatency("pop_expired_timeouts", () =>
      multi.exec(),
    )) as Array<[Error | null, unknown]> | null;

    if (!results || results.length === 0) {
      return [];
    }

    const members = (results[0]?.[1] as string[]) || [];

    if (members.length === 0) {
      return [];
    }

    return members.map((member) => {
      const [reqId, difficulty] = member.split(":");
      return { reqId, difficulty: difficulty as Difficulty };
    });
  },

  /**
   * Check if user has an active match request
   * Returns reqId if found, null otherwise
   */
  async getUserActiveRequest(userId: string): Promise<string | null> {
    const redis = getRedis();
    return trackLatency("get", () => redis.get(`user:active:${userId}`));
  },

  /**
   * Set user's active request (used for deduplication)
   */
  async setUserActiveRequest(
    userId: string,
    reqId: string,
    ttlSeconds: number,
  ): Promise<void> {
    const redis = getRedis();
    await trackLatency("setex", () =>
      redis.setex(`user:active:${userId}`, ttlSeconds, reqId),
    );
  },

  /**
   * Remove user's active request marker
   */
  async removeUserActiveRequest(userId: string): Promise<void> {
    const redis = getRedis();
    await trackLatency("del", () => redis.del(`user:active:${userId}`));
  },

  /**
   * Track active SSE connection for a request (prevents multiple connections)
   */
  async setActiveSSEConnection(reqId: string, ttlSeconds: number = 60): Promise<boolean> {
    const redis = getRedis();
    // Use SET with NX (only set if not exists) for atomic check-and-set
    const result = await trackLatency("set", () =>
      redis.set(`sse:active:${reqId}`, Date.now().toString(), "EX", ttlSeconds, "NX"),
    );
    return result === "OK";
  },

  /**
   * Remove active SSE connection marker
   */
  async removeActiveSSEConnection(reqId: string): Promise<void> {
    const redis = getRedis();
    await trackLatency("del", () => redis.del(`sse:active:${reqId}`));
  },

  /**
   * Check if SSE connection exists for a request
   */
  async hasActiveSSEConnection(reqId: string): Promise<boolean> {
    const redis = getRedis();
    const exists = await trackLatency("exists", () => redis.exists(`sse:active:${reqId}`));
    return exists === 1;
  },
};
